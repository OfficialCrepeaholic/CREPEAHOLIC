<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Crepe by CREPEAHOLIC</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Rubik+Bubbles&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap');
        body {
            font-family: 'Comic Neue', cursive;
            background-color: #f5f5dc;
            overflow: hidden;
            touch-action: manipulation;
        }
        #gameCanvas {
            background-color: #e6d2aa;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .title {
            font-family: 'Rubik Bubbles', cursive;
            color: #8b7355;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }
        .subtitle {
            font-family: 'Dancing Script', cursive;
            color: #8b7355;
        }
        .btn {
            background-color: #8b7355;
            color: white;
            transition: all 0.3s;
        }
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .score-box {
            background-color: white;
            border: 2px solid #8b7355;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .voucher {
            border: 2px dashed #8b7355;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">
    <div id="startScreen" class="text-center">
        <h1 class="title text-5xl md:text-6xl mb-2">Flappy Crepe</h1>
        <p class="subtitle text-2xl md:text-3xl mb-8">by CREPEAHOLIC</p>
        
        <div class="bg-white rounded-xl p-6 shadow-lg max-w-md mx-auto mb-8">
            <h3 class="font-bold text-xl mb-4 text-amber-800">|HOW TO PLAY|</h3>
            <p class="mb-2 text-left flex items-center">
                <i data-feather="mouse-pointer" class="mr-2"></i> CLICK OR TAP TO MAKE CREPE FLY!
            </p>
            <p class="text-left flex items-center">
                <i data-feather="award" class="mr-2"></i> SCORE 10 POINTS TO WIN A FREE CREPE ROLL!
            </p>
        </div>
        
        <button id="startBtn" class="btn px-8 py-3 rounded-full text-xl font-bold">
            START GAME
        </button>
    </div>

    <div id="gameScreen" class="hidden w-full max-w-md relative">
        <div class="flex justify-between items-center mb-2">
            <h2 class="title text-2xl">CREPEAHOLIC</h2>
            <div id="scoreDisplay" class="score-box px-4 py-1 font-bold">
                Score: <span id="score">0</span>
            </div>
        </div>
        <canvas id="gameCanvas" class="w-full border-2 border-amber-200"></canvas>
    </div>

    <div id="victoryScreen" class="hidden text-center">
        <h1 class="title text-5xl md:text-6xl mb-6 text-green-600">CONGRATULATIONS!</h1>
        
        <div class="voucher p-6 mb-8 max-w-md mx-auto">
            <h3 class="font-bold text-2xl mb-2">YOU'VE WON!</h3>
            <p class="text-xl">Free Crepe Roll</p>
            <p class="text-lg">- Flavor of Your Choice (1PC) -</p>
        </div>
        
        <a href="https://forms.gle/bxDsNUgxPMb2oem68" target="_blank" class="btn px-8 py-3 rounded-full text-xl font-bold inline-block mb-4">
            CLAIM YOUR PRIZE
        </a>
        <button id="playAgainBtn1" class="btn px-8 py-3 rounded-full text-xl font-bold inline-block ml-4">
            PLAY AGAIN
        </button>
    </div>

    <div id="gameOverScreen" class="hidden text-center">
        <h1 class="title text-5xl md:text-6xl mb-6 text-red-600">GAME OVER!</h1>
        <p class="text-2xl mb-8">Better luck next time!</p>
        <a href="https://forms.gle/bxDsNUgxPMb2oem68" class="btn px-8 py-3 rounded-full text-xl font-bold inline-block mb-4">
            ORDER NOW
        </a>
<button id="playAgainBtn2" class="btn px-8 py-3 rounded-full text-xl font-bold inline-block ml-4">
            TRY AGAIN
        </button>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameRunning = false;
        let score = 0;
        let highScore = 0;
        let animationId;

        // Set canvas size
        function resizeCanvas() {
            const headerHeight = document.querySelector('h2').offsetHeight;
            const padding = 20;
            canvas.width = window.innerWidth - (padding * 2);
            canvas.height = window.innerHeight - headerHeight - (padding * 3);
        }
resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // Game elements
        const crepe = {
            x: 100,
            y: canvas.height / 2,
            width: 60,
            height: 45,
velocity: 0,
            gravity: 0.5,
            jumpForce: -10,
            flapWings: false,
            flapTimer: 0
        };

        const obstacles = [];
        const obstacleWidth = 60;
        const gapHeight = canvas.height * 0.9;
        let obstacleTimer = 0;
        const obstacleInterval = 1500; // ms
        let obstacleSpeed = 3;
        let easyObstaclesCount = 0;
// Game screens
        const startScreen = document.getElementById('startScreen');
        const gameScreen = document.getElementById('gameScreen');
        const victoryScreen = document.getElementById('victoryScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const scoreDisplay = document.getElementById('score');

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn1').addEventListener('click', startGame);
        document.getElementById('playAgainBtn2').addEventListener('click', startGame);
        canvas.addEventListener('click', flap);
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                flap();
            }
        });
        document.addEventListener('touchstart', flap);

        // Start game
        function startGame() {
            startScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            victoryScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            // Reset game state
            score = 0;
            scoreDisplay.textContent = score;
            obstacles.length = 0;
            crepe.y = canvas.height / 2;
            crepe.velocity = 0;
            obstacleSpeed = 3;
            easyObstaclesCount = 0;
gameRunning = true;
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop();
        }

        // Flap wings
        function flap() {
            if (!gameRunning) return;
            crepe.velocity = crepe.jumpForce;
            crepe.flapWings = true;
            crepe.flapTimer = 10;
        }

        // Game loop
        function gameLoop() {
            if (!gameRunning) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update crepe
            crepe.velocity += crepe.gravity;
            crepe.y += crepe.velocity;
            
            // Check boundaries
            if (crepe.y < 0) {
                crepe.y = 0;
                crepe.velocity = 0;
            }
            
            if (crepe.y + crepe.height > canvas.height) {
                gameOver();
                return;
            }
            
            // Update flap animation
            if (crepe.flapWings) {
                crepe.flapTimer--;
                if (crepe.flapTimer <= 0) {
                    crepe.flapWings = false;
                }
            }
            // Draw crepe
            ctx.font = `${crepe.height}px Arial`;
            ctx.fillText('ðŸ¥ž', crepe.x, crepe.y + crepe.height);
            
            // Only show wings when flapping
            if (crepe.flapWings) {
                ctx.font = `${crepe.height}px Arial`;
                // Left wing (mirrored)
                ctx.save();
                ctx.translate(crepe.x - 5, crepe.y + crepe.height/2 - 5);
                ctx.scale(-1, 1);
                ctx.fillText('ðŸª½', 0, 0);
                ctx.restore();
                // Right wing
                ctx.fillText('ðŸª½', crepe.x + crepe.width - 15, crepe.y + crepe.height/2 - 5);
// Bounce effect when flapping
                ctx.font = `${crepe.height * 1.1}px Arial`;
                ctx.fillText('ðŸ¥ž', crepe.x, crepe.y + crepe.height * 1.1);
            }
// Add new obstacles
            obstacleTimer += 16; // assuming 60fps
            if (obstacleTimer >= obstacleInterval) {
                addObstacle();
                obstacleTimer = 0;
                // Increase speed slightly (except for first 3 obstacles)
                if (easyObstaclesCount >= 3) {
                    obstacleSpeed += 0.1;
                }
}
            
            // Update and draw obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.x -= obstacle.speed || obstacleSpeed;
// Check if passed
                if (!obstacle.passed && obstacle.x + obstacleWidth < crepe.x) {
                    obstacle.passed = true;
                    score++;
                    scoreDisplay.textContent = score;
                    
                    // Check for victory
                    if (score === 10) {
                        victory();
                        return;
                    }
                }
                
                // Draw top obstacle (spoon)
                ctx.fillStyle = '#d3d3d3';
                ctx.fillRect(obstacle.x, 0, obstacleWidth, obstacle.topHeight);
                // Spoon details
                ctx.fillStyle = '#a9a9a9';
                ctx.beginPath();
                ctx.arc(obstacle.x + obstacleWidth/2, obstacle.topHeight - 10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw bottom obstacle (fork)
                ctx.fillStyle = '#d3d3d3';
                ctx.fillRect(obstacle.x, obstacle.bottomY, obstacleWidth, canvas.height - obstacle.bottomY);
                // Fork details
                ctx.fillStyle = '#a9a9a9';
                for (let j = 0; j < 3; j++) {
                    ctx.fillRect(obstacle.x + 5 + j*10, obstacle.bottomY, 5, 15);
                }
                
                // Remove if off screen
                if (obstacle.x + obstacleWidth < 0) {
                    obstacles.splice(i, 1);
                }
                // Collision detection - using tighter hitbox around visible crepe
                const crepeHitbox = {
                    x: crepe.x + crepe.width * 0.075, // 7.5% offset
                    y: crepe.y + crepe.height * 0.075, // 7.5% offset  
                    width: crepe.width * 0.85, // 15% smaller
                    height: crepe.height * 0.85 // 15% smaller
                };
if (
                    crepeHitbox.x + crepeHitbox.width > obstacle.x &&
                    crepeHitbox.x < obstacle.x + obstacleWidth &&
                    (crepeHitbox.y < obstacle.topHeight || crepeHitbox.y + crepeHitbox.height > obstacle.bottomY)
                ) {
                    gameOver();
                    return;
                }
// Random vertical movement for some obstacles
                if (obstacle.moving) {
                    if (obstacle.movingUp) {
                        obstacle.topHeight -= 0.5;
                        obstacle.bottomY -= 0.5;
                        if (obstacle.topHeight < 50) {
                            obstacle.movingUp = false;
                        }
                    } else {
                        obstacle.topHeight += 0.5;
                        obstacle.bottomY += 0.5;
                        if (obstacle.bottomY > canvas.height - 50) {
                            obstacle.movingUp = true;
                        }
                    }
                }
            }
            
            animationId = requestAnimationFrame(gameLoop);
        }

        // Add new obstacle
        function addObstacle() {
            const minTopHeight = 50;
            let currentGap = gapHeight;
            let currentSpeed = obstacleSpeed;
            let isMoving = Math.random() < 0.2;
            // Gradually adjust gap width based on obstacle count
            if (easyObstaclesCount === 0) {
                currentGap = gapHeight * 0.50; // 50% narrower
                currentSpeed = 4;
                isMoving = true;
            } else if (easyObstaclesCount === 1) {
                currentGap = gapHeight * 0.45; // 55% narrower
                currentSpeed = 4;
                isMoving = true;
            } else if (easyObstaclesCount === 2) {
                currentGap = gapHeight * 0.40; // 60% narrower'
                currentSpeed = 4;
                isMoving = true;
            } else if (easyObstaclesCount === 3) {
                currentGap = gapHeight * 0.35; // 65% narrower
                currentSpeed = 3.5;
            } else if (easyObstaclesCount === 4) {
                currentGap = gapHeight * 0.35; // 65% narrower
                currentSpeed = 3.5;
            } else if (easyObstaclesCount === 5) {
                currentGap = gapHeight * 0.35; // 65% narrower
                currentSpeed = 3.5;
            } else if (easyObstaclesCount === 6) {
                currentGap = gapHeight * 0.30; // 70% narrower
                currentSpeed = 3.5;
            } else if (easyObstaclesCount === 7) {
                currentGap = gapHeight * 0.20; // 80% narrower
                currentSpeed = 3;
            } else if (easyObstaclesCount === 8) {
                currentGap = gapHeight * 0.10; // 90% narrower
                currentSpeed = 3;
            } else if (easyObstaclesCount === 9) {
                currentGap = gapHeight * 0.01; // 99% narrower
                currentSpeed = 3;
            }
            easyObstaclesCount++;
const maxTopHeight = canvas.height - currentGap - 50;
const topHeight = minTopHeight + Math.random() * (maxTopHeight - minTopHeight);
            const bottomY = topHeight + currentGap;
            
            obstacles.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: bottomY,
                passed: false,
                moving: isMoving,
                movingUp: Math.random() < 0.5,
                speed: currentSpeed
            });
        }
// Game over
        function gameOver() {
            gameRunning = false;
            gameScreen.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            cancelAnimationFrame(animationId);
        }

        // Victory
        function victory() {
            gameRunning = false;
            gameScreen.classList.add('hidden');
            victoryScreen.classList.remove('hidden');
            cancelAnimationFrame(animationId);
        }

        // Initialize feather icons
        feather.replace();
    </script>
</body>
</html>